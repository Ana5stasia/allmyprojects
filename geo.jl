# Выбор типа данных для представления точек (плоскости)
struct Point
    x::Float64
    y::Float64
end

# Задача поиска точки пересечения (если она есть) двух
# заданных отрезков на плоскости
function segment_intersection(s1, s2)
    # s1 и s2 - кортежи вида ((x1, y1), (x2, y2))
    dx1 = s1[2][1] - s1[1][1]
    dy1 = s1[2][2] - s1[1][2]
    dx2 = s2[2][1] - s2[1][1]
    dy2 = s2[2][2] - s2[1][2]

    # Вычисляем определитель матрицы 2x2
    det = dx1 * dy2 - dy1 * dx2

    # Если определитель равен 0, то отрезки либо параллельны,
    # либо пересекаются в бесконечности, либо совпадают
    if det == 0.0
        return nothing
    end

    # Вычисляем координаты точки пересечения
    x = (dy2 * (s1[1][1] - s2[1][1]) + dy1 * (s2[1][1] - s1[1][1])) / det
    y = (dx2 * (s1[1][2] - s2[1][2]) + dx1 * (s2[1][2] - s1[1][2])) / det

    # Проверяем, что точка пересечения принадлежит обоим отрезкам
    if ((x - s1[1][1]) * (x - s1[2][1]) <= 0.0 &&
        (y - s1[1][2]) * (y - s1[2][2]) <= 0.0 &&
        (x - s2[1][1]) * (x - s2[2][1]) <= 0.0 &&
        (y - s2[1][2]) * (y - s2[2][2]) <= 0.0)
        return Point(x, y)
    else
        return nothing
    end
end

# Задача вычисления угла между двумя плоскими прямыми
function angle_between_lines(l1, l2)
    # l1 и l2 - кортежи вида ((x1, y1), (x2, y2))
    dx1 = l1[2][1] - l1[1][1]
    dy1 = l1[2][2] - l1[1][2]
    dx2 = l2[2][1] - l2[1][1]
    dy2 = l2[2][2] - l2[1][2]

    # Вычисляем скалярное произведение векторов, задающих прямые
    dot_product = dx1 * dx2 + dy1 * dy2

    # Вычисляем длины векторов, задающих прямые
    length1 = sqrt(dx1^2 + dy1^2)
    length2 = sqrt(dx2^2 + dy2^2)

    # Вычисляем косинус угла между прямыми
    cos_angle = dot_product / (length1 * length2)

    # Вычисляем угол между прямыми в радианах
    angle = acos(cos_angle)

    # Возвращаем угол между прямыми в градусах
    return angle * 180.0 / pi
end

# Задача определения, лежат ли две заданные точки плоскости
# по одну сторону от заданной границы области; в частности - по
# одну сторону от заданной прямой
function same_side(p1, p2, boundary)
    # p1 и p2 - экземпляры структуры Point
    # boundary - кортеж вида ((x1, y1), (x2, y2))
    dx = boundary[2][1] - boundary[1][1]
    dy = boundary[2][2] - boundary[1][2]

    # Вычисляем знаки векторного произведения векторов
    # (p1 - boundary[1]) и (boundary[2] - boundary[1])
    sign1 = (p1.x - boundary[1][1]) * dy - (p1.y - boundary[1][2]) * dx
    sign2 = (p2.x - boundary[1][1]) * dy - (p2.y - boundary[1][2]) * dx

    # Если знаки векторного произведения одинаковы, то точки
```
le
# Задача определения, лежит ли заданная точка плоскости
# внутри заданного выпуклого многоугольника
function point_in_polygon(p, polygon)
    # p - экземпляр структуры Point
    # polygon - массив экземпляров структуры Point,
    # задающий вершины многоугольника

    # Добавляем в массив вершин многоугольника его первую
    # вершину, чтобы гарантировать, что он замкнут
    push!(polygon, polygon[1])

    # Инициализируем счетчик пересечений границ многоугольника
    # лучом, проведенным из точки вправо
    intersections = 0

    # Перебираем все ребра многоугольника
    for i in 1:(length(polygon) - 1)
        # Вычисляем координаты левой и правой точек ребра
        left_point = polygon[i]
        right_point = polygon[i + 1]

        # Если левая точка ребра левее луча, проведенного из
        # точки вправо, то ребро не может пересекать луч,
        # поэтому пропускаем его
        if left_point.x > p.x
            continue
        end

        # Если правая точка ребра левее луча, проведенного из
        # точки вправо, то ребро полностью лежит слева от луча,
        # поэтому пропускаем его
        if right_point.x <= p.x
            continue
        end

        # Вычисляем координату точки пересечения ребра с лучом
        intersection_y = p.y + (right_point.y - left_point.y) * (p.x - left_point.x) / (right_point.x - left_point.x)

        # Если точка пересечения выше точки, то счетчик
        # пересечений инкрементируется
        if intersection_y > p.y
            intersections += 1
        end
    end

    # Если счетчик пересечений нечетный, то точка лежит внутри
    # многоугольника, иначе - снаружи
    return intersections % 2 == 1
end

# Задача определения, является ли заданный плоский
# многоугольник выпуклым
function is_convex(polygon)
    # polygon - массив экземпляров структуры Point,
    # задающий вершины многоугольника

    # Добавляем в массив вершин многоугольника его первую
    # вершину, чтобы гарантировать, что он замкнут
    push!(polygon, polygon[1])

    # Инициализируем флаг, указывающий, является ли многоугольник
    # выпуклым
    is_convex = true

    # Перебираем все ребра многоугольника
    for i in 1:(length(polygon) - 1)
        # Вычисляем координаты левой и правой точек ребра
        left_point = polygon[i]
        right_point = polygon[i + 1]

        # Вычисляем координаты векторов, сонаправленных с ребром
        # и перпендикулярным ему вектором
        dx = right_point.x - left_point.x
        dy = right_point.y - left_point.y
        px = -dy
        py = dx

        # Перебираем все вершины многоугольника, кроме левой и
        # правой точек текущего ребра
        for j in 1:(length(polygon) - 1)
            if j == i || j == i + 1
                continue
            end

            # Вычисляем скалярное произведение вектора,
            # соединяющего левую точку ребра с текущей
            ````
ver
            vx = polygon[j + 1].x - left_point.x
            vy = polygon[j + 1].y - left_point.y

            # Если скалярное произведение вектора, соединяющего
            # левую точку ребра с текущей вершиной, и вектора,
            # перпендикулярного ребру, больше нуля, то текущая
            # вершина лежит слева от ребра, иначе - справа
            if vx * py - vy * px > 0
                # Если текущая вершина лежит слева от ребра, а
                # предыдущая - справа, то многоугольник не является
                # выпуклым
                if j > 1 && vx * py - vy * px < 0
                    is_convex = false
                    break
                end
            elseif j > 1 && vx * py - vy * px > 0
                is_convex = false
                break
            end
        end

        if !is_convex
            break
        end
    end

    return is_convex
end

# Задача построения выпуклой оболочки заданного множества
# точек плоскости
function convex_hull(points)
    # points - массив экземпляров структуры Point

    # Сортируем точки по координате x, а при равенстве координат x -
    # по координате y
    sort!(points, by = x -> (x.x, x.y))

    # Инициализируем массивы, содержащие вершины верхней и нижней
    # частей выпуклой оболочки
    upper_hull = [points[1], points[2]]]
    lower_hull = [points[1], points[2]]]

    # Перебираем все точки, начиная с третьей
    for i in 3:length(points)
        # Добавляем текущую точку в массив, содержащий вершины
        # верхней части выпуклой оболочки, пока она образует
        # левый поворот с предыдущими двумя точками
        while length(upper_hull) > 1 && cross_product(upper_hull[end - 1], upper_hull[end], points[i]) <= 0
            pop!(upper_hull)
        end
        push!(upper_hull, points[i])

        # Добавляем текущую точку в массив, содержащий вершины
        # нижней части выпуклой оболочки, пока она образует
        # правый поворот с предыдущими двумя точками
        while length(lower_hull) > 1 && cross_product(lower_hull[end - 1], lower_hull[end], points[i]) >= 0
            pop!(lower_hull)
        end
        push!(lower_hull, points[i])
    end

    # Объединяем массивы, содержащие вершины верхней и нижней
    # частей выпуклой оболочки, и возвращаем получившийся массив
    return vcat(upper_hull[1:end-1], reverse(lower_hull[1:end-1]))
end

# Вспомогательная функция для вычисления векторного произведения
# трех точек
function cross_product(p1, p2, p3)
    (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)
end
